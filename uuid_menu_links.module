<?php
/**
 * @file
 */

/**
 * Implements hook_menu_alter().
 */
function uuid_menu_links_menu_alter(&$menu) {
  $original_menu = $menu;
  foreach ($original_menu as $routing_path => $menu_item) {
    foreach (_uuid_menu_links_menu_load_token_map() as $original => $new) {
      if (0 === strpos($routing_path, $original)) {
        $new_routing_path = str_replace($original, $new, $routing_path);
        $menu[$new_routing_path] = $menu_item;
        unset($menu[$routing_path]);
      }
    }
  }
}

/**
 * Implements hook_menu_get_object_load_type_alter().
 */
function uuid_menu_links_menu_get_object_load_type_alter(&$type, $original_type) {
  switch ($original_type) {
    case 'node':
      if ('node' == arg(0)) {
        $type = 'uuid_menu_links_universal_node';
      }
      break;

    case 'taxonomy_term':
      if ('taxonomy' == arg(0) && 'term' == arg(1)) {
        $type = 'uuid_menu_links_universal_taxonomy_term';
      }
      break;
  }
}

/**
 * Load hook for %uuid_menu_links_universal_node menu token.
 *
 * @param string $identifier
 *   The identifier of the node to load, either a UUID or node id.
 *
 * @return object
 *   Returns the single loaded node by the $identifier if exists, otherwise false.
 */
function uuid_menu_links_universal_node_load($identifier = NULL) {
  $node = entity_uuid_load('node', array($identifier));
  $node = !empty($node) && is_array($node) ? reset($node) : NULL;
  if (empty($node)) {
    $node = node_load($identifier);
  }
  return $node;
}

/**
 * Load hook for %uuid_menu_links_universal_taxonomy_term menu token.
 *
 * @param string $identifier
 *   The identifier of the taxonomy term to load, either UUID or TID.
 *
 * @return object
 *   Returns the single loaded term by the $identifier if exists, otherwise false.
 */
function uuid_menu_links_universal_taxonomy_term_load($identifier = NULL) {
  $taxonomy_term = entity_uuid_load('node', array($identifier));
  $taxonomy_term = !empty($taxonomy_term) && is_array($taxonomy_term) ? reset($taxonomy_term) : NULL;
  if (empty($taxonomy_term)) {
    $taxonomy_term = taxonomy_term_load($identifier);
  }
  return $taxonomy_term;
}

/**
 * Implements hook_menu_link_insert().
 */
function uuid_menu_links_menu_link_insert($link) {
  _uuid_menu_links_menu_link_save($link);
}

/**
 * Implements hook_menu_link_update().
 */
function uuid_menu_links_menu_link_update($link) {
  _uuid_menu_links_menu_link_save($link);
}

/**
 * Implements hook_path_insert().
 */
function uuid_menu_links_path_insert($path) {
  _uuid_menu_links_path_save($path);
}

/**
 * Implements hook_path_update().
 */
function uuid_menu_links_path_update($path) {
  _uuid_menu_links_path_save($path);
}

/**
 * Updates a menu link to contain the UUID instead of a non-portable identifier.
 *
 * @param array
 *   The menu link to update.
 */
function _uuid_menu_links_menu_link_save($link) {
  $link_path = explode('/', $link['link_path']);
  switch ($link_path[0]) {
    case 'node':
      if (isset($link_path[1]) && is_numeric($link_path[1])) {
        $node = node_load($link_path[1]);
        if (!empty($node->uuid)) {
          $link_path[1] = $node->uuid;
          $link['link_path'] = implode('/', $link_path);
          menu_link_save($link);
        }
      }
      break;

    case 'taxonomy':
      if (isset($link_path[1]) && 'term' == $link_path[1] && isset($link_path[2]) && is_numeric($link_path[2])) {
        $taxonomy_term = taxonomy_term_load($link_path[2]);
        if (!empty($taxonomy_term->uuid)) {
          $link_path[2] = $taxonomy_term->uuid;
          $link['link_path'] = implode('/', $link_path);
          menu_link_save($link);
        }
      }
      break;
  }
}

/**
 * Handles parsing and re-saving of any paths requiring a UUID.
 *
 * @param array $path
 *   The path to resave.
 */
function _uuid_menu_links_path_save($path) {
  $source = explode('/', $path['source']);
  if (empty($source)) {
    return;
  }

  switch ($source[0]) {
    case 'node':
      if (isset($source[1]) && is_numeric($source[1])) {
        $node = node_load($source[1]);
        if (!empty($node->uuid)) {
          $source[1] = $node->uuid;
          $path['source'] = implode('/', $source);
          path_save($path);
        }
      }
      break;

    case 'taxonomy':
      if (isset($source[1]) && 'term' == $source[1] && isset($source[2]) && is_numeric($source[2])) {
        $taxonomy_term = taxonomy_term_load($source[2]);
        if (!empty($taxonomy_term->uuid)) {
          $source[2] = $taxonomy_term->uuid;
          $path['source'] = implode('/', $source);
          path_save($path);
        }
      }
      break;
  } // end switch ($source[0]).
}

/**
 * Returns a map of menu routing elements to be re-written.
 *
 * @return array
 *   Returns the map of routing pieces, original => new.
 */
function _uuid_menu_links_menu_load_token_map() {
  return array(
    'node/%node' => 'node/%uuid_menu_links_universal_node',
    'taxonomy/term/%taxonomy_term' => 'taxonomy/term/%uuid_menu_links_universal_taxonomy_term',
  );
}

