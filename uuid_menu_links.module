<?php
/**
 * @file
 */

/**
 * Implements hook_module_implements_alter().
 */
function uuid_menu_links_module_implements_alter(&$implementations, $hook) {
  if ('menu_alter' === $hook) {
    // Move UUID Menu Links `menu_alter` implementation to the bottom.
    $group = $implementations['uuid_menu_links'];
    unset($implementations['uuid_menu_links']);
    $implementations['uuid_menu_links'] = $group;
  }
}

/**
 * Implements hook_menu_alter().
 */
function uuid_menu_links_menu_alter(&$menu) {
  $original_menu = $menu;
  foreach ($original_menu as $routing_path => $menu_item) {
    foreach (_uuid_menu_links_menu_load_token_map() as $original => $new) {
      if (0 === strpos($routing_path, $original)) {
        $new_routing_path = str_replace($original, $new, $routing_path);
        $menu[$new_routing_path] = $menu_item;
        unset($menu[$routing_path]);
      }
    }
  }
}

/**
 * Implements hook_menu_link_insert().
 */
function uuid_menu_links_menu_link_insert($link) {
  _uuid_menu_links_menu_link_save($link);
}

/**
 * Implements hook_menu_link_update().
 */
function uuid_menu_links_menu_link_update($link) {
  _uuid_menu_links_menu_link_save($link);
}

/**
 * Implements hook_path_insert().
 */
function uuid_menu_links_path_insert($path) {
  _uuid_menu_links_path_save($path);
}

/**
 * Implements hook_path_update().
 */
function uuid_menu_links_path_update($path) {
  _uuid_menu_links_path_save($path);
}

/**
 * Implements hook_menu_get_object_load_type_alter().
 */
function uuid_menu_links_menu_get_object_load_type_alter(&$type, $original_type) {
  switch ($original_type) {
    case 'node':
      if ('node' == arg(0)) {
        $type = 'uuid_menu_links_universal_node';
      }
      break;

    case 'taxonomy_term':
      if ('taxonomy' == arg(0) && 'term' == arg(1)) {
        $type = 'uuid_menu_links_universal_taxonomy_term';
      }
      break;
  }
}

/**
 * Implements hook_pathauto_alias_alter().
 */
function uuid_menu_links_pathauto_alias_alter($alias, &$context) {
  uuid_menu_links_transform_source($context['source']);
}

/**
 * Implements hook_pathauto_existing_alias_source_alter().
 */
function uuid_menu_links_pathauto_existing_alias_source_alter(&$source) {
  uuid_menu_links_transform_source($source);
}

/**
 * Load hook for %uuid_menu_links_universal_node menu token.
 *
 * @param string $identifier
 *   The identifier of the node to load, either a UUID or node id.
 *
 * @return object
 *   Returns the single loaded node by the $identifier if exists, otherwise false.
 */
function uuid_menu_links_universal_node_load($identifier = NULL) {
  $node = entity_uuid_load('node', array($identifier));
  $node = !empty($node) && is_array($node) ? reset($node) : NULL;
  if (empty($node)) {
    $node = node_load($identifier);
  }
  return $node;
}

/**
 * Load hook for %uuid_menu_links_universal_taxonomy_term menu token.
 *
 * @param string $identifier
 *   The identifier of the taxonomy term to load, either UUID or TID.
 *
 * @return object
 *   Returns the single loaded term by the $identifier if exists, otherwise false.
 */
function uuid_menu_links_universal_taxonomy_term_load($identifier = NULL) {
  $taxonomy_term = entity_uuid_load('node', array($identifier));
  $taxonomy_term = !empty($taxonomy_term) && is_array($taxonomy_term) ? reset($taxonomy_term) : NULL;
  if (empty($taxonomy_term)) {
    $taxonomy_term = taxonomy_term_load($identifier);
  }
  return $taxonomy_term;
}

/**
 * Updates a menu link to contain the UUID instead of a non-portable identifier.
 *
 * @param array
 *   The menu link to update.
 */
function _uuid_menu_links_menu_link_save($link) {
  $original_link_path = $link['link_path'];
  uuid_menu_links_transform_source($link['link_path']);
  if ($original_link_path != $link['link_path']) {
    menu_link_save($link);
  }
}

/**
 * Handles parsing and re-saving of any paths requiring a UUID.
 *
 * @param array $path
 *   The path to resave.
 */
function _uuid_menu_links_path_save($path) {
  $original_source = $path['source'];
  uuid_menu_links_transform_source($path['source']);
  if ($original_source != $path['source']) {
    path_save($path);
  }
}

/**
 * Returns a map of menu routing elements to be re-written.
 *
 * @return array
 *   Returns the map of routing pieces, original => new.
 */
function _uuid_menu_links_menu_load_token_map() {
  return array(
    'node/%node' => 'node/%uuid_menu_links_universal_node',
    'taxonomy/term/%taxonomy_term' => 'taxonomy/term/%uuid_menu_links_universal_taxonomy_term',
  );
}

/**
 * Transforms a source url to that containing a UUID.
 *
 * @param string $source
 *   The source url passed by reference to transform.
 */
function uuid_menu_links_transform_source(&$source) {
  $pieces = explode('/', $source);
  if (empty($pieces)) {
    return;
  }

  switch ($pieces[0]) {
    case 'node':
      if (isset($pieces[1]) && is_numeric($pieces[1])) {
        $node = node_load($pieces[1]);
        if (!empty($node->uuid)) {
          $pieces[1] = $node->uuid;
          $source = implode('/', $pieces);
        }
      }
      break;

    case 'taxonomy':
      if (isset($pieces[1]) && 'term' == $pieces[1] && isset($pieces[2]) && is_numeric($pieces[2])) {
        $taxonomy_term = taxonomy_term_load($pieces[2]);
        if (!empty($taxonomy_term->uuid)) {
          $pieces[2] = $taxonomy_term->uuid;
          $source = implode('/', $pieces);
        }
      }
      break;
  }
}

